\chapter{Introduction}
\label{cha:intro}
Microcontrollers (MCUs) are computing systems that are integrated into a larger ecosystem; in this case, they acquire the adjective Embedded. This means that they are designed to perform a specific function that requires a software implementation (programmed in C or assembly) and a hardware implementation (interconnectivity wires and sensor handle). They operate in a closed environment and elaborate the physical inputs, which may be visual, acoustic, and with more recent technology even tactile or movement-based. These are elaborated to generate an output, which may be feedback to a larger system, an audio response, or a trigger depending on the microcontroller specifics. 
The programmer can implement a desired application for real-time use, allowing personalized functionalities and optimizing possibilities. In application development, the objective is to achieve cost reduction in power and energy terms and the opportunity to build a desired application, adding more than one feature at the same time, and connecting various sensors thanks to their peripherals. 
\section{TinyML Concept and Limits}
\label{sec:context}                                                                      
MCU's technology made steps ahead in optimizing the computation velocity, meanwhile minimizing power consumption, and a result is TinyML (Tiny Machine Learning). These devices enable machine and deep learning models to operate on an MCU, allowing performing actions like Keyword Spotting, recognizing a specific word in an audio stream, or identifying objects in an image.
These functionalities can be implemented thanks to a Neural Network, which is typically trained on cloud resources in the Python programming language, and this leads to performing only the inference phase on these tiny devices. This approach does not allow data exploitation directly, limiting incremental training or adapting algorithms through the device's life. This is a limit on the Machine Learning side, but on the tiny one, there are some trade-offs. A direct consequence of being too small devices is having limited memory to reduce power consumption, so sometimes adapting a neural network, which typically may occupy much memory, is not easy and requires precision reduction. 
\section{Goals - TinySV}
\label{sec:tinysv}
This thesis studies how to adapt a TinyML device's system based on an application that performs Speaker Verification, whose task consists of recognizing the identity of a user with reference samples and comparing them with a processed input audio stream. The objective originally was creating a Keyword Spotting model (KWS) and a Speaker Verification (SV) one, trying to adapt that algorithm on two Syntiant TinyML NDP101 devices, but because of an NDA, the access to documentation was inaccessible. The KWS development was possible thanks to Edge Impulse\cite{edgeimpulse_syntiant_tinyml}, but the SV approach\cite{dvector_extractor_TinySV} using dvectors is a technique that is not supported by Edge Impulse and due to the inability to access a model compression tool. To preserve the initial idea, the model was tested as it would be on a Syntiant TinyML NDP101, to show the validation of the technique. The objective of this thesis is to show the feasibility of this idea from a software perspective and to demonstrate if deployability on the model is possible. All codes used in this thesis are provided on a GitHub repository\footnotemark{}\footnotetext{Thesis GitHub Repository - https://github.com/Gotta003/Syntiant-NDP101-Speaker-Verification-Thesis}\cite{thesisresources}.

\section{Brief Summary}
The thesis is divided into chapters. After this introduction, Chapter 2 aims to present theoretical concepts that will be used in this thesis, like Audio Processing, Deep Learning concepts, KWS, and SV. Chapter 3 explains the workflow of the model's training techniques adopted. Chapter 4 introduces the general methodology of the final objective and explains how it works. Chapter 5 draws up the results obtained from computer testing code, which emulates Syntiant NDP101 behavior. Chapter 6 contains the thesis conclusion and future possible work.
\newpage