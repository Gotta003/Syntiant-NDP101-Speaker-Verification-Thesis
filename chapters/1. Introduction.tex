\chapter{Introduction}
\label{cha:intro}
The microcontrollers (MCU) are computing systems, which are integrated in a larger system and in that case they are called embedded system, to perform a specific function that need a software implementation (programmed in C or assembly) and a hardware one (interconnectivity wires and sensor handle)
They operate in a closed environment and elaborate environment inputs which may be visual, acustic and with more recent technology even tactile or movement and elaborate it to generate an output which may be an action in a bigger system, an audio response or a trigger depending on the microcontroller specifics. 
The programmer can implement a desired application for real time use, which allows personalization of the functionalities and the possibility of optimization. In an application development, the objective is achieving cost reduction in power and energy terms, the possibility of build a desired application and adding more than one feature at the same time connecting various sensors thanks to their peripherals.    
%Each MCU can be optimized in a specific sub-application, like monitoring, communications and networking (Internet-of-Thing) and digital signal processing.
\section{TinyML Concept and Limits}
\label{sec:context}                                                                      
MCU's technology made steps ahead in optimizing the computation velocity, meanwhile minimizing power consumption and a result is TinyML (Tiny Machine Learning). These devices enable machine and deep learning models to operate on a MCU, allowing performing actions Keyword Spotting, recognizing a specific word in an audio stream, or identifying objects in an image.
These functionalities can be implemented thanks to a Neural Network, which is trained typically on cloud resources in Python programming language and this leads in performing only the inference phase on these tiny devices. This approach does not allow data exploitation directly, limiting incremental training or adapting algorithm through the device life. This is a limit on the Machine Learning side, but on the Tiny one there are some trade-offs. A direct consequence of being really small devices is having limited memory to reduce power consumption, so sometimes adapting a Neural Network which typically may occupy much memory isn't easy and requires precision reduction. 
\section{Goals - TinySV}
\label{sec:tinysv}
This thesis studies how to adapt with a TinyML devices base system that performs Speaker Verification, which task consists in recognizing the identity of a user with references samples and comparing them with an input audio stream. The objective originally was creating a Keyword Spotting model (KWS) and a Speaker Verification (SV) one, trying to adapt that algorithm on two Syntiant TinyML NDP101 devices, but because of a NDA problem the access to documentation was inaccessible. The KWS development was possible thanks to Edge Impulse\cite{edgeimpulse_syntiant_tinyml}, but the SV approach\cite{dvector_extractor_TinySV} uses a technique not supported by Edge Impulse and because of the inability of accessing to a model compression tool. To preserve the initial idea, the model was tested as it would be a Syntiant TinyML NDP101, to show the validation of the technique. This thesis objective is to show the feasibility of this idea from a software perspective and partially hardware, using another MCU (STM32), with a single model verification. All the codes used in this thesis is provided on a GitHub repository\footnotemark{}\footnotetext{Thesis GitHub Repository - https://github.com/Gotta003/Thesis}
\section{Brief Summary}
The thesis is divided into chapters. After this introduction, Chapter 2 aims to present theoretical concepts that will be used in this thesis, like Audio Processing, KWS and SV. Chapter 3 introduces the general methodology of the final objective and explains how it works. Chapter 4 explains the work flow of models training and optimization. Chapter 5 presents the software C code implementation for deploying both algorithms. Chapter 6 draws up the results obtained from computer testing.
\newpage